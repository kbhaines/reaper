desc:VSL SE12 Articulation Controller V2
slider1:art_type=0<0,2,1{C1/C2,C1/C7 (Cello),C6/C7}>Articulation KS Config
slider2:auto_xf=0<0,1,1{Off,On}>Auto-XF control
in_pin:none
out_pin:none

@init
function blip_note(offset, note) (
  midisend(offset, $x90, note, 127);
  midisend(offset, $x80, note, 0);
);
dim1=(art_type < 2 ? 24 : 84);
dim2=(art_type == 0 ? 36 : 96);

// Keyswitch constants. These encode in 2x 4 bits, dimension 1
// is in the upper 4 bits and range 0-15 (0=C1, for example). 
// Dimension 2 is in the lower 4 bits, and range 0 to 15.
// So 0x21 = notes D1 + C#2 in an instrument with C1/C2 style 
// keyswitches. It's harlmess to send an unused dimension note.


ks_short_stac= $x00;
ks_short_det = $x01;
ks_long_sus  = $x10;
ks_long_marc = $x11;
ks_long_trem = $x12;
ks_leg_leg   = $x20;
ks_leg_port  = $x21;
ks_leg_sus   = $x21;   // brass/wind
ks_dyn_sfz   = $x30;
ks_sfz       = $x30;   // brass/wind
ks_dyn_sfz_trem = $x31;
ks_trem_trem = $x40;
ks_trem_marc = $x41;
ks_pizz      = $x50;


// this is the last articulation set by an actual PC message
pc_art = ks_long_sus;

// this is the articulation last set by a notation
active_notn_art = -1;


art_notn = 0;
note_on_ctr = 1;


// returns an articulation code based on the string passed, or
// -1 if the string wasn't matched. It's not an optimum solution
// but works fine.
function parse_notation(msg) (
  artic = -1;
  match("*custom sfz", msg) ? artic = ks_sfz;
  match("*custom pizz", msg) ? artic = ks_pizz;
  match("*phrase %d slur*", msg) ? artic = ks_leg_leg;
  match("*ornament tremolo", msg) ? artic = ks_trem_trem;
  match("*articulation marcato", msg) ? artic = ks_long_marc;
  match("*articulation staccato", msg) ? artic = ks_short_stac;
  match("*custom sus phrase*", msg) ? artic = ks_leg_sus;
  match("*custom xf ornament tremolo", msg) ? artic = ks_long_trem;
  match("*custom sfz ornament tremolo", msg) ? artic = ks_dyn_sfz_trem;
  match("*phrase %d slur*technique bend", msg) ? artic = ks_leg_port;
  match("*articulation marcato ornament tremolo", msg) ? artic = ks_trem_marc;
  artic;
);


function set_ks_from_pc(offset, pc) (
    blip_note(offset, dim1 + (pc >> 4));
    d2 = pc & 15; 
    blip_note(offset, dim2 + d2);
);

// return 0 if the message wasn't handled
function handle_pc(offset, msg1, msg2, msg3) (
  (msg1 == $xC0 ) ? (
    (msg2 < 126) ? (
      pc_art = msg2;
      set_ks_from_pc(offset, pc_art);
    ) : (
      (msg2 == 126 ) ? midisend(offset, $xB0, 28, 127) : midisend(offset, $xB0, 28, 0)
     );
     1
  ) : 0;
);

current_xf = 64;
// Handle the xf control for an articulated note
function handle_xf_control(offset, msg) (
  (auto_xf ) ? (
    set_mode_xf_top +=1 ;
    xf_mode = 127; // Cross-fade default = on
    match("*custom pizz", msg) ? xf_mode = 0;
    match("*articulation staccato", msg) ? xf_mode = 0;
    (current_xf != xf_mode) ? (
      current_xf = xf_mode;
      set_mode_xf += 1;
      midisend(offset, $xB0, 28, current_xf);
    );
  );
);

@block
while (midirecv_str(offset, #str)) (
  msg1 = str_getchar(#str, 0);
  msg2 = str_getchar(#str, 1);
  msg3 = str_getchar(#str, 2);
  
  // Look for a string event which is a notation
  msg1 == $xFF && msg2 == $x0F ? (
    strcpy_from(#msg, #str, 2);
    art_notn = parse_notation(#msg);
    (art_notn >=0 ) ? (
      active_notn_art != art_notn ? (
        set_ks_from_pc(offset, art_notn);
        active_notn_art = art_notn;
      );
      
      // two note-on messages will reset notation-articulation
      note_on_ctr = 2;
    );
    handle_xf_control(offset, #msg);
  ) : (
    handle_pc(offset, msg1, msg2, msg3) == 0 ? (
      msg1 == $x90 && msg3 > 0 && note_on_ctr ? (
        note_on_ctr -=1 ;
        note_on_ctr == 0 ? (
          set_ks_from_pc(offset, pc_art);
          handle_xf_control(offset, "reset");
          active_notn_art = -1;
        );
      );
      midisend_str(offset, #str); // passthrough other events
    ) : ( 
      active_notn_art =0;  // PC disables active articulation
    );
  );
); 

desc:Articulation KS Mapper
in_pin:none
out_pin:none

slider1:/articulation-maps:vsl-special-vi14.txt:Articulation Map
slider2:use_default=0<0,50,1>Default Articulation # (0=none)
slider3:aux_keyswitch=0<0,10,1{Off, C-1,C0,C1,C2,C3,C4,C5,C6,C7,C8>Auxiliary Keyswitches
@slider

@init
ext_midi_bus = 1.0;

MAX_ARTICULATIONS = 50;
NUM_ARTS = 0;
ACTIVE_ART = -1;

// Store in global string array
art_match_strings = 1;
art_keys_str = art_match_strings + MAX_ARTICULATIONS;

// KS midi are 4 byte numbers representing the max 4 key switch notes
// in order from low to high byte
articulation_ks_midi = 1;

// note_art is an array holding a midi note number's assigned articulation
// indexed by chan * 128 + note_id
note_art = articulation_ks_midi + MAX_ARTICULATIONS;
note_art_size = 128 * 16;
memset(note_art, -1, note_art_size);

function blip_note(offset, chan, note) (
  midisend(offset, $x90+chan, note, 127);
  midisend(offset, $x80+chan, note, 0);
);

function parse_note_seq(note_seq) 
  local(seq, note, oct, acc, i, rest) (
  acc = 0;
  i = 0;
  strcpy(seq, note_seq);
  while (strlen(seq) > 1 && i < 4) (
    match("C%d%0s", seq, oct, #rest)  ? ( note = 0 ):
    match("C#%d%0s", seq, oct, #rest) ? ( note = 1 ):
  
    match("D%d%0s", seq, oct, #rest)  ? ( note = 2 ):
    match("D#%d%0s", seq, oct, #rest) ? ( note = 3 ):
  
    match("E%d%0s", seq, oct, #rest)  ? ( note = 4 ):
    match("F%d%0s", seq, oct, #rest)  ? ( note = 5 ):
    match("F#%d%0s", seq, oct, #rest) ? ( note = 6 ):
  
    match("G%d%0s", seq, oct, #rest)  ? ( note = 7 ):
    match("G#%d%0s", seq, oct, #rest) ? ( note = 8 ):
    match("A%d%0s", seq, oct, #rest)  ? ( note = 9 ):
    match("A#%d%0s", seq, oct, #rest) ? ( note = 10 ):
    match("B%d%0s", seq, oct, #rest)  ? ( note = 11 ): (note = 99);

    strcpy(seq, #rest);
    acc += (1 + note + (oct + 1) * 12) << (i * 8);
    i+=1;
  );
  acc;
);

function load_arts() local (handle, i, art_str, keys, art_name) (

  // TODO: File change/reload logic
  strcpy_fromslider(#art_filename, slider1);
  !((handle = file_open(#art_filename)) < 0) ? ( // file_open successful
    i = 0;
    while (file_string(handle,#art_str) > 0 && i < MAX_ARTICULATIONS) (
      match("%S %s\n*",#art_str,#keys,#art_name) ||
      match("%S %s\r*",#art_str,#keys,#art_name) ? (
        strcpy(art_match_strings+i, #art_name);
        strcpy(art_keys_str+i, #keys);
        articulation_ks_midi[i] = parse_note_seq(#keys);
        i += 1;
      );
    );
    file_close(handle);
    NUM_ARTS = i;
  );
);

function parse_notation(note_art_str) (
  art_match = -1;
  scan = 0;
  sprintf(#pnn, ">> %s", note_art_str);
  while (scan < NUM_ARTS && (art_match < 0)) (
    //#tmps = art_match_strings + scan;
    //#tmpy = art_keys_str + scan;
    
    match(art_match_strings + scan, note_art_str) ? 
      art_match = scan;
    scan += 1;
  );
  art_match;
);

function is_text_evt(msg1, msg2) (
  msg1 == $xFF && msg2 == $x0F;
);


function is_note_on(msg1) (
  (msg1 & $xF0) == $x90;
);

function send_ks_for_articulation(offset, chan, art_id) (
  art_id != ACTIVE_ART ? (
    ks_midi = articulation_ks_midi[art_id];
    //sprintf(#ks_xx, "%X", ks_midi);
    while (ks_midi) (
    // TODO  -1?
      blip_note(offset, chan, (ks_midi & $xFF)-1);
      ks_midi = ks_midi >> 8;
    );
    ACTIVE_ART = art_id;
  );
);

function set_articulation(str) (
  strcpy_from(#msga, #str, 2);
  match("NOTE %d %d %s", #msga, note_chan, note_id, #art_str) ? (
    //sprintf(#matched,"%s %d %d %d", #art_str, note_chan, note_id,
      //parse_notation(#art_str));
    note_art[note_chan * 128 + note_id] = parse_notation(#art_str);
  );
);

function check_articulation(offset, chan, note_id) (
  i = chan * 128 + note_id;
  art_id = note_art[i];
  art_id == -1 && use_default ? art_id = use_default-1;
  art_id >= 0 ? (
    send_ks_for_articulation(offset, chan, art_id);
    note_art[i] = -1;
  );
);
  

@slider
load_arts();

// TEST DATA
//test_pn = parse_notation("phrase 1 slur begin");
//sprintf(#test_pn, "%X", test_pn);
//#test_pn_expected = "191B0000";
//sprintf(#test_pns, "%X", parse_note_seq("C-1C2C3F#0"));
//#test_pns_expected = "1253113";

@block
while (midirecv_str(offset, #str)) (
  msg1 = str_getchar(#str, 0);
  msg2 = str_getchar(#str, 1);
  msg3 = str_getchar(#str, 2);
  
  is_text_evt(msg1, msg2) ? (
    set_articulation(str);
  ) : is_note_on(msg1) ? (
    check_articulation(offset, msg1 & $x0F, msg2);
  );
  midisend_str(offset, #str);
);


@gfx 360 360
margin_left = 20;
margin_top = 10;
text_colour = 0.9;
drawn_art = -2;
NUM_ARTS > 0 && drawn_art != ACTIVE_ART ? ( 
  gfx_setfont(1, "arial", 12, 'b');
  gfx_measurestr("00 G#9G#9G#9G9", note_width, note_height);
  gfx_a = 1;
  gfx_r = gfx_g = gfx_b = text_colour;
  gfx_x = margin_left;
  gfx_y = margin_top;
  gfx_printf("%d articulations loaded\n", NUM_ARTS);
  i = 0;
  split_at = floor((NUM_ARTS+1) / 2);
  loop(NUM_ARTS,
    gfx_x = left = i < split_at ? 
      margin_left : margin_left + (gfx_w / 2);
    //gfx_y = top = i < split_at ? 
      //margin_top + (i + 1) * (gfx_texth + 5):
      //margin_top + (i - split_at + 1 ) * (gfx_texth + 5);
    gfx_y = top = margin_top + (1+( i % split_at)) * (gfx_texth +5);
    sprintf(#head, "%02d %s", i+1, art_keys_str + i);
    gfx_drawstr(#head);
    gfx_x = note_width+left;
    gfx_drawstr(art_match_strings + i);
    i == ACTIVE_ART ? (
      gfx_r = gfx_b = 0;
      gfx_g = 1;
      gfx_a = 0.4;
      gfx_rect(left-margin_left, top, gfx_x, gfx_texth);
      gfx_r = gfx_b = gfx_g = text_colour;
      gfx_a = 1;
    );
    i += 1;
  );
  drawn_art = ACTIVE_ART;
);
